# MapMaker 迁移指南

## 介绍

`MapMaker`上的所有缓存相关方法都已被弃用，取而代之的是[`CacheBuilder`]中的类似方法，并计划将其删除。
11.0.0版本已经删除了`evictionListener`、`expireAfterWrite`和`expireAfterAccess`。未来的版本将删除`makeComputingMap`和`expiration`。

大多数`MapMaker` 用例应该迁移到`CacheBuilder`或[`AtomicLongMap`]中。具体来说，
当使用`MapMaker`构造具有`AtomicLong`值的映射时，通常应该迁移到`AtomicLongMap`。
使用`MapMaker`缓存功能的其他情况(包括`MapMaker.makeComputingMap(Function)`的所有使用)应该迁移到`CacheBuilder`。

从`MapMaker.makeMap()`迁移到[`CacheBuilder.build()`]很简单，但是从`MapMaker.makeComputingMap(Function)`迁移到
[`CacheBuilder.build(CacheLoader)`]涉及一些细微的行为变化。
具体来说，`MapMaker.makeComputingMap(Function)`返回一个`ConcurrentMap`，而`CacheBuilder.build(CacheLoader)`返回一个[`LoadingCache`]。
虽然`LoadingCache`有一个[`asMap()`]方法，但该映射返回的映射与`MapMaker`创建的映射有很大不同。

## `MapMaker` and `ConcurrentMap`

`MapMaker.makeComputingMap(Function)` returned a magical (and ill-behaved)
`ConcurrentMap`. Specifically, calls to `Map.get(Object)` on the returned map
would automatically compute values for absent keys using the specified
`Function`. These computations would be shared by all concurrent computations on
the same key. Such maps were, in effect, autovivification maps.

At first glance this behavior is tremendously useful, but the specific
implementation of this functionality behind a plain `ConcurrentMap` was riddled
with issues.

Having a `Map` that auto-creates entries on `get` was simply a big mistake. It
breaks type-safety (you can use it to store a key in the map that isn't of the
map's key type!). Bad things will happen if that `Map` accidentally gets passed
to another `Map`'s `equals()` method. Common idioms for `Map` usage (in the
absence of null values) are based on the assumption of interchangeability of
`containsKey(k)` and `(get(k) != null)`, and those coding patterns will break.
Etc.

We studied this issue very closely, and concluded that our library will be
easier to use when collections are just collections, iterators are just
iterators, and things that are fancier than those have public types that convey
their behavior sufficiently.

## `CacheBuilder` and `LoadingCache`

And thus we introduced the `LoadingCache` interface. The primary intent of this
new interface was to encapsulate a `get(K)` method which auto-created entries,
while still exposing an `asMap()` view which allowed traditional map-style
access to the cache internals. In other words, the magical `get` from
`MapMaker.makeComputingMap(Function)` was semantically separated from the other
`ConcurrentMap` methods. Note that `LoadingCache.get(K)` will automatically load
absent entries, however `LoadingCache.asMap.get(Object)` will *not*.

The new `LoadingCache` interface came with a new builder, `CacheBuilder`,
patterned after `MapMaker` but with an explicit focus on caching, and only
capable of producing `LoadingCache` (and `Cache`) instances, instead of
`ConcurrentMap`s.

## Migrating from `MapMaker` to `CacheBuilder`

Now that we understand the key distinction between `MapMaker` and `LoadingCache`
we turn to the subject of migrating old code from `MapMaker` to `CacheBuilder`.

### Computing caches

The biggest difference is the change from using a plain `Function` to compute
values to a more sophisticated [`CacheLoader`] type.

`CacheLoader` has a few major differences from `Function`:

*   Its [`load(K key)`] method is permitted to throw exceptions.
*   It provides a [`loadAll(Iterable<? extends K>)`] method to load multiple
    keys at once -- possibly concurrently. (By default, `loadAll` just
    sequentially loads each key individually with the `load` method.)
*   It provides a [`reload(K key, V oldValue)`] method for use in *refreshing*
    cached values asynchronously, for caches configured with
    [`refreshAfterWrite`]. By default, this synchronously calls `load`.

The simplest way to migrate a `Function`-based computing map to a `CacheLoader`
is the [`CacheLoader.from(Function)`] adapter, which views a `Function` as a
`CacheLoader`, no special effort required. That said, it's silly to call
`CacheLoader.from(new Function<K, V>() {...})` when you can just write

```java
new CacheLoader<K, V>() {
  public V load(K key) {
    // copy/paste code from Function.apply
  }
};
```

### `asMap` view

The biggest difference between the computing maps generated by
`MapMaker.makeComputingMap` and the `ConcurrentMap asMap()` view of a `Cache` is
that the `asMap()` view will never compute new values on a call to
`asMap().get(key)`. This is specifically deliberate to avoid the "magical"
unpredictable behavior of computing maps.

[`CacheBuilder`]: http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html
[`AtomicLongMap`]: http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/AtomicLongMap.html
[`CacheBuilder.build()`]: http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#build--
[`CacheBuilder.build(CacheLoader)`]: http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#build-com.google.common.cache.CacheLoader-
[`LoadingCache`]: http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/LoadingCache.html
[`asMap()`]: http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/LoadingCache.html#asMap--
[`CacheLoader`]: http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheLoader.html
[`load(K key)`]: http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheLoader.html#load-K-
[`loadAll(Iterable<? extends K>)`]: http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheLoader.html#loadAll-java.lang.Iterable-
[`reload(K key, V oldValue)`]: http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheLoader.html#reload-K-V-
[`refreshAfterWrite`]: http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#refreshAfterWrite-long-java.util.concurrent.TimeUnit-
[`CacheLoader.from(Function)`]: http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheLoader.html#from-com.google.common.base.Function-
