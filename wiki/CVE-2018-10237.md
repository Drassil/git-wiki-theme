# CVE-2018-10237

## Description(描述)

无限内存分配在谷歌Guava11.0和24.1允许远程攻击者进行拒绝服务攻击服务器依赖这个库
和反序列化attacker-provided数据,因为`AtomicDoubleArray`类(当序列化的Java序列化)
和`CompoundOrdering`类(当序列化使用GWT序列化)执行蒸机分配不适当的检查客户端所发送和数据大小是否合理。

## Additional Information(附加信息)

During deserialization, two Guava classes accept a caller-specified size
parameter and eagerly allocate an array of that size:

*   [`AtomicDoubleArray`] \(when serialized with Java serialization)
*   [`CompoundOrdering`] \(when serialized with GWT serialization)

If a server deserializes instances sent by an attacker, the attacker can quickly
force the server to allocate all its memory, without even sending the promised
number of elements. Note that most servers that accept serialized data will
deserialize objects of these types as long as they are on the classpath, even if
they are not used by the server. (It is possible to set up an allow- or denylist
for Java serialization, but few service owners do. GWT serialization does
operate with an allowlist by default, but it is usually a large, automatically
generated list that often includes the problem class.)

[Guava 24.1.1]和[Guava 25.0]消除了数组的优先分配。
这修复了漏洞。
[Guava 24.1.1] and [Guava 25.0] eliminate the eager allocation of the arrays.
This fixes the vulnerability.

Note that it will still be possible for an attacker to send an
`AtomicDoubleArray` or `CompoundOrdering` with a large number of items. However,
this problem is endemic to serialization. (For example, it's present in
[`ArrayList`].) Service owners who are concerned about this problem should set a
limit on the size of the object graph that their servers will accept. (For Java
serialization, see [JEP 290], which also permits including and excluding
particular classes, useful for defense in depth and as a mitigation if you can't
immediately upgrade your version of Guava. For GWT-RPC, consider migrating to
another RPC system, as it is deprecated. Aside from migration, we don't know the
best practices for GWT-RPC users for addressing the endemic problem.)

Final note for users of old versions of Guava: Guava previously had [a batch of
similar problems], which were fixed in Guava 19.0.

## Metadata

*   Vulnerability Type: Other (Unbounded memory allocation)
*   Affected Product Code Base: introduced in 11.0; last present in 24.1; fixed
    in 24.1.1 and 25.0
*   Affected Component: code that depends on Guava and uses Java serialization
    or GWT-RPC
*   Attack Type: Remote
*   Impact: Denial of Service
*   Attack Vectors: To be affected, a server running Guava must deserialize data
    sent by an attacker (either Java serialization or GWT-RPC).
*   Discoverer: Apostolos Giannakidis

[CVE Entry](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-10237)

[`AtomicDoubleArray`]: https://github.com/google/guava/blob/fd919e54a55ba169dc7d9f54b7b3485aa7fa0970/guava/src/com/google/common/util/concurrent/AtomicDoubleArray.java#L252
[`CompoundOrdering`]: https://github.com/google/guava/blob/acf29b389bc9ff8701f69d05b30e9d899bc10e35/guava-gwt/src/com/google/common/collect/CompoundOrdering_CustomFieldSerializer.java#L39
[Guava 24.1.1]: https://github.com/google/guava/releases/tag/v24.1.1
[Guava 25.0]: https://github.com/google/guava/releases/tag/v25.0
[`ArrayList`]: http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/ArrayList.java#l766
[JEP 290]: http://openjdk.java.net/jeps/290
[a batch of similar problems]: https://github.com/google/guava/commit/a70f009926809b9a37ebbc16ebbc9cf71030be11
